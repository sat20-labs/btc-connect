// Generated by dts-bundle-generator v8.1.2

import React from 'react';

export type WalletNetwork = "livenet" | "testnet";
export type Balance = {
	confirmed: number;
	unconfirmed: number;
	total: number;
};
export interface BtcWalletConnectOptions {
	network?: BtcWalletNetwork;
	defaultConnectorId?: BtcConnectorId;
}
export type BtcWalletNetwork = "livenet" | "testnet";
export type BtcConnectorId = "unisat" | "okx";
export type AccountsChangedEvent = (event: "networkChanged", handler: (accounts: Array<string>) => void) => void;
export type NetworkChangedEvent = (event: "networkChanged", handler: (network: BtcWalletNetwork) => void) => void;
export type MessageType = "ecdsa" | "bip322-simple";
export type Address = string;
declare abstract class BtcConnector {
	/** Unique connector id */
	abstract readonly id: string;
	/** Connector name */
	abstract readonly name: string;
	abstract readonly logo: string;
	/** Extension or Snap homepage */
	abstract homepage: string;
	/** Whether connector is usable */
	ready: boolean;
	connected: boolean;
	address: Address | undefined;
	publicKey: string | undefined;
	network: WalletNetwork;
	constructor(network: WalletNetwork);
	abstract connect(): Promise<boolean>;
	abstract sendToAddress(toAddress: string, amount: number): Promise<string>;
	abstract signPsbt(psbtHex: string, options?: any): Promise<string>;
	disconnect(): void;
	getAccount(): string | undefined;
	isAuthorized(): boolean;
	getNetwork(): Promise<WalletNetwork>;
	getPublicKey(): Promise<string>;
}
declare namespace UnisatWalletTypes {
	type AccountsChangedEvent = (event: "accountsChanged" | "networkChanged", handler: (accounts: Array<string> | string) => void) => void;
	type Inscription = {
		inscriptionId: string;
		inscriptionNumber: string;
		address: string;
		outputValue: string;
		content: string;
		contentLength: string;
		contentType: string;
		preview: string;
		timestamp: number;
		offset: number;
		genesisTransaction: string;
		location: string;
	};
	type GetInscriptionsResult = {
		total: number;
		list: Inscription[];
	};
	type SendInscriptionsResult = {
		txid: string;
	};
	type Network = "livenet" | "testnet";
}
export type Unisat = {
	requestAccounts: () => Promise<string[]>;
	getAccounts: () => Promise<string[]>;
	on: UnisatWalletTypes.AccountsChangedEvent;
	removeListener: UnisatWalletTypes.AccountsChangedEvent;
	getInscriptions: (cursor: number, size: number) => Promise<UnisatWalletTypes.GetInscriptionsResult>;
	sendInscription: (address: string, inscriptionId: string, options?: {
		feeRate: number;
	}) => Promise<UnisatWalletTypes.SendInscriptionsResult>;
	switchNetwork: (network: "livenet" | "testnet") => Promise<void>;
	getNetwork: () => Promise<UnisatWalletTypes.Network>;
	getPublicKey: () => Promise<string>;
	getBalance: () => Promise<Balance>;
	sendBitcoin: (address: string, atomicAmount: number, options?: {
		feeRate: number;
	}) => Promise<string>;
	pushTx: ({ rawtx }: {
		rawtx: string;
	}) => Promise<string>;
	pushPsbt: (psbtHex: string) => Promise<string>;
	signMessage: (message: string, type?: "ecdsa" | "bip322-simple") => Promise<string>;
	signPsbt: (psbtHex: string, options?: {
		autoFinalized?: boolean;
		toSignInputs: {
			index: number;
			address?: string;
			publicKey?: string;
			sighashTypes?: number[];
			disableTweakSigner?: boolean;
		}[];
	}) => Promise<string>;
	signPsbts: (psbtHexs: string[], options?: {
		autoFinalized?: boolean;
		toSignInputs: {
			index: number;
			address?: string;
			publicKey?: string;
			sighashTypes?: number[];
			disableTweakSigner?: boolean;
		};
	}[]) => Promise<string[]>;
};
declare class UnisatConnector extends BtcConnector {
	readonly id = "unisat";
	readonly name: string;
	readonly logo: string;
	homepage: string;
	banance: Balance;
	unisat: Unisat;
	constructor(network: WalletNetwork);
	on(event: "accountsChanged" | "networkChanged", handler: any): void;
	removeListener(event: "accountsChanged" | "networkChanged", handler: any): void;
	connect(): Promise<boolean>;
	getCurrentInfo(): Promise<void>;
	disconnect(): Promise<void>;
	getAccounts(): Promise<string[]>;
	sendToAddress(toAddress: string, amount: number): Promise<string>;
	switchNetwork(network: WalletNetwork): Promise<void>;
	getPublicKey(): Promise<string>;
	getBalance(): Promise<Balance>;
	signPsbt(psbtHex: string, options?: any): Promise<string>;
	signMessage(message: string): Promise<string>;
	signPsbts(psbtHexs: string[], options?: any): Promise<string[]>;
	pushTx(rawTx: string): Promise<string>;
	pushPsbt(psbtHex: string): Promise<string>;
}
declare namespace OkxWalletTypes {
	interface AddressInfo {
		address: string;
		publicKey: string;
		compressedPublicKey: string;
	}
	type OnEvent = (event: "accountsChanged" | "accountChanged", handler: (accounts: Array<string> | Array<AddressInfo>) => void) => void;
	type Inscription = {
		inscriptionId: string;
		inscriptionNumber: string;
		address: string;
		outputValue: string;
		content: string;
		contentLength: string;
		contentType: string;
		preview: string;
		timestamp: number;
		offset: number;
		genesisTransaction: string;
		location: string;
	};
	type GetInscriptionsResult = {
		total: number;
		list: Inscription[];
	};
	type Network = "livenet" | "testnet";
	interface ConnectResult {
		address: string;
		publicKey: string;
	}
	interface SendProps {
		from: string;
		to: string;
		value: number;
		satBytes: number;
	}
	interface SendResult {
		txhash: string;
	}
	interface TransferNftProps {
		from: string;
		to: string;
		data: string | string[];
	}
	interface TransferNftResult {
		txhash: string;
	}
	interface SplitUtxoProps {
		from: string;
		amount: number;
	}
	interface SplitUtxoResult {
		utxos: {
			txId: string;
			vOut: number;
			amount: number;
			rawTransaction: string;
		}[];
	}
	interface InscribeProps {
		type: 51 | 58;
		from: string;
		tick: string;
		tid: string;
	}
	interface MintProps {
		type: 60 | 50 | 51 | 62 | 61 | 36 | 33 | 34 | 35 | 58;
		from: string;
		inscriptions: {
			contentType: string;
			body: string;
		}[];
	}
	interface MintResult {
		commitAddrs: string[];
		commitTx: string;
		revealTxs: string[];
		commitTxFee: number;
		revealTxFees: number[];
		feeRate: number;
		size: number;
	}
}
export type OkxWallet = {
	connect: () => Promise<OkxWalletTypes.ConnectResult>;
	requestAccounts: () => Promise<string[]>;
	getAccounts: () => Promise<string[]>;
	getNetwork: () => Promise<OkxWalletTypes.Network>;
	getPublicKey: () => Promise<string>;
	getBalance: () => Promise<Balance>;
	getInscriptions: (cursor: number, size: number) => Promise<OkxWalletTypes.GetInscriptionsResult>;
	sendBitcoin: (toAddress: string, satoshis: number, options?: {
		feeRate: number;
	}) => Promise<string>;
	sendInscription: (address: string, inscriptionId: string, options?: {
		feeRate: number;
	}) => Promise<string>;
	transferNft: ({ from, to, data, }: OkxWalletTypes.TransferNftProps) => Promise<OkxWalletTypes.TransferNftResult>;
	send: ({ from, to, value, satBytes, }: OkxWalletTypes.SendProps) => Promise<OkxWalletTypes.SendResult>;
	signMessage: (message: string, type?: "ecdsa" | "bip322-simple") => Promise<string>;
	pushTx: (rawtx: string) => Promise<string>;
	splitUtxo: ({ from, amount, }: OkxWalletTypes.SplitUtxoProps) => Promise<OkxWalletTypes.SplitUtxoResult>;
	inscribe: ({ type, from, tick, tid, }: OkxWalletTypes.InscribeProps) => Promise<string>;
	mint: ({ type, from, inscriptions, }: OkxWalletTypes.MintProps) => Promise<OkxWalletTypes.MintResult>;
	signPsbt: (psbtHex: string, options?: {
		autoFinalized?: boolean;
		toSignInputs: {
			index: number;
			address?: string;
			publicKey?: string;
			sighashTypes?: number[];
			disableTweakSigner?: boolean;
		}[];
	}) => Promise<string>;
	signPsbts: (psbtHexs: string[], options?: {
		autoFinalized?: boolean;
		toSignInputs: {
			index: number;
			address?: string;
			publicKey?: string;
			sighashTypes?: number[];
			disableTweakSigner?: boolean;
		};
	}[]) => Promise<string[]>;
	pushPsbt: (psbtHex: string) => Promise<string>;
	on: OkxWalletTypes.OnEvent;
};
declare class OkxConnector extends BtcConnector {
	readonly id = "okx";
	readonly name: string;
	readonly logo: string;
	homepage: string;
	banance: Balance;
	okxwallet: OkxWallet;
	constructor(network: WalletNetwork);
	on(event: "accountsChanged" | "accountChanged", handler: any): void;
	connect(): Promise<boolean>;
	getCurrentInfo(): Promise<void>;
	disconnect(): Promise<void>;
	getAccounts(): Promise<string[]>;
	getNetwork(): Promise<WalletNetwork>;
	getPublicKey(): Promise<string>;
	getBalance(): Promise<Balance>;
	sendToAddress(toAddress: string, amount: number): Promise<string>;
	switchNetwork(network: WalletNetwork): Promise<void>;
	signPsbt(psbtHex: string, options?: any): Promise<string>;
	signMessage(message: string): Promise<string>;
	signPsbts(psbtHexs: string[], options?: any): Promise<string[]>;
	pushTx(rawTx: string): Promise<string>;
	pushPsbt(psbtHex: string): Promise<string>;
}
export type Connector = UnisatConnector | OkxConnector;
export interface BtcConnectors {
	id: BtcConnectorId;
	instance: Connector;
	installed: boolean;
}
declare class BtcWalletConnect {
	private local_storage_key;
	private local_disconnect_key;
	connectorId: BtcConnectorId;
	localConnectorId?: BtcConnectorId;
	disConnectStatus: boolean;
	connected: boolean;
	address?: string;
	publicKey?: string;
	network: BtcWalletNetwork;
	balance: Balance;
	connectors: BtcConnectors[];
	connector?: Connector;
	constructor({ network, defaultConnectorId, }: BtcWalletConnectOptions);
	switchConnector(id: BtcConnectorId): Connector;
	connect(): Promise<boolean>;
	private getCurrentInfo;
	check(): Promise<false | undefined>;
	disconnect(): Promise<void>;
	getAccounts(): Promise<string[]>;
	getNetwork(): Promise<WalletNetwork>;
	switchNetwork(network: BtcWalletNetwork): Promise<void>;
	sendToAddress(toAddress: string, amount: number): Promise<string>;
	signMessage(message: string, type?: MessageType): Promise<string>;
	signPsbt(psbtHex: string, options?: any): Promise<string>;
	signPsbts(psbtHexs: string[], options?: any): Promise<string[]>;
	pushTx(rawTx: string): Promise<string>;
	pushPsbt(psbtHex: string): Promise<string>;
	on: NetworkChangedEvent | AccountsChangedEvent;
	removeListener: NetworkChangedEvent | AccountsChangedEvent;
}
export interface WalletConnectReactProps {
	config?: BtcWalletConnectOptions;
	theme?: "light" | "dark";
	ui?: {
		connectClass?: string;
		disconnectClass?: string;
	};
	text?: {
		connectText?: string;
		disconnectText?: string;
		modalTitle?: string;
	};
	onConnectSuccess?: (btcWallet: BtcWalletConnect) => void;
	onConnectError?: (error: any) => void;
	onDisconnectSuccess?: () => void;
	onDisconnectError?: (error: any) => void;
	children?: any;
}
export declare const WalletConnectReact: ({ config: { network, defaultConnectorId }, theme, ui: { connectClass, disconnectClass }, text: { connectText, disconnectText, modalTitle }, onConnectSuccess, onConnectError, onDisconnectSuccess, onDisconnectError, children, }: WalletConnectReactProps) => React.JSX.Element;
export type WalletState = {
	btcWallet?: BtcWalletConnect;
	balance: Balance;
	publicKey: string;
	address: string;
	connected: boolean;
	initStatus: boolean;
	network: BtcWalletNetwork;
	connectorId?: BtcConnectorId;
	localConnectorId?: BtcConnectorId;
	connector?: Connector;
	connectors?: {
		id: BtcConnectorId;
		name: string;
		logo: string;
		connector: any;
		installed: boolean;
	}[];
};
export type WalletActions = {
	init: (config: BtcWalletConnectOptions) => void;
	check: () => void;
	connect: () => void;
	disconnect: () => void;
	switchConnector: (id: BtcConnectorId) => void;
	switchNetwork: () => void;
};
export type WalletStore = WalletState & WalletActions;
export declare const useReactWalletStore: import("zustand").UseBoundStore<Omit<import("zustand").StoreApi<WalletStore>, "setState"> & {
	setState<A extends string | {
		type: string;
	}>(partial: WalletStore | Partial<WalletStore> | ((state: WalletStore) => WalletStore | Partial<WalletStore>), replace?: boolean | undefined, action?: A | undefined): void;
}>;

export {};
